#include "MenuScene.h"

#include "RopeGame.h"

#include "../commons.h"
#include "../Configuration.h"
#include "../Logging.h"

#include <math/VectorUtilities.h>

#include <graphics/CameraUtilities.h>


namespace ad {
namespace grapito {


auto makeInterpolation(std::shared_ptr<graphics::AppInterface> aAppInterface, GLfloat aStartFactor, GLfloat aEndFactor)
{
    GLfloat viewedWidth_w = math::getRatio<float>(aAppInterface->getFramebufferSize()) * menu::gViewedHeight;
    return math::makeInterpolation<math::ease::SmoothStep>(
        aStartFactor * viewedWidth_w,
        aEndFactor   * viewedWidth_w,
        menu::gTransitionDuration);
}


MenuScene::MenuScene(Menu aMenu, std::shared_ptr<graphics::AppInterface> aAppInterface) :
    mMenu{std::move(aMenu)},
    mAppInterface{std::move(aAppInterface)},
    mShaping{mAppInterface->getFramebufferSize()},
    // Useless, it is setup before transitions. But there is no default ctor.
    mMenuXPosition{makeInterpolation(mAppInterface, 0.f, 0.f)} 
{}


UpdateStatus MenuScene::update(
        GrapitoTimer & aTimer,
        const GameInputState & aInputs,
        StateMachine & aStateMachine)
{
    if (aInputs.get(Controller::Keyboard)[Command::Up].positiveEdge())
    {
        mMenu.mSelected = std::min(mMenu.mSelected - 1, mMenu.size() - 1);
    }
    else if (aInputs.get(Controller::Keyboard)[Command::Down].positiveEdge())
    {
        mMenu.mSelected = (mMenu.mSelected + 1) % mMenu.size();
    }
    else if (aInputs.get(Controller::Keyboard)[Command::Start].positiveEdge())
    {
        mMenu.selected().mCallback(aStateMachine, mAppInterface);
        // When the menu is poping itself, the OpenGL is issuing an error when return SwapBuffers:
        // GL_INVALID_VALUE error generated. Program handle does not refer to an object generated by OpenGL.
        // We avoid it by not swapping to cover this case.
        // TODO get a better understanding of the error scenario.
        return UpdateStatus::KeepFrame;
    }

    renderMenu();
    return UpdateStatus::SwapBuffers;
}

void MenuScene::beforeEnter()
{
    mMenuXPosition = makeInterpolation(mAppInterface, 0.5f, -0.5f);
}


void MenuScene::beforeExit()
{
    mMenuXPosition = makeInterpolation(mAppInterface, -0.5f, -1.5f);
}


std::pair<TransitionProgress, UpdateStatus> MenuScene::scrollMenu(GrapitoTimer & aTimer)
{
    Rectangle viewed = graphics::getViewRectangle(mAppInterface->getFramebufferSize(), menu::gViewedHeight);
    viewed.origin().x() = mMenuXPosition.advance(aTimer.delta());
    setViewedRectangle(mShaping, viewed);
    renderMenu();

    return {
        mMenuXPosition.isCompleted() ? TransitionProgress::Complete : TransitionProgress::Ongoing,
        UpdateStatus::SwapBuffers
    };
}


void MenuScene::renderMenu()
{
    graphics::AppInterface::clear();

    GLfloat menuHeight = mMenu.size() * menu::gButtonSize.height()
        + (mMenu.size() - 1) * menu::gButtonSpacing;
    GLfloat buttonY = menuHeight / 2.f - menu::gButtonSize.height() / 2.f;
    GLfloat incrementY = menu::gButtonSize.height() + menu::gButtonSpacing;

    for (std::size_t buttonId = 0; buttonId != mMenu.size(); ++buttonId)
    {
        mShaping.addRectangle({
            Rectangle{ {0.f, buttonY}, menu::gButtonSize }.centered(),
            buttonId == mMenu.mSelected ? menu::gSelectedColor : menu::gButtonColor });
        buttonY -= incrementY;
    }
    mShaping.render();
}


} // namespace grapito
} // namespace ad
