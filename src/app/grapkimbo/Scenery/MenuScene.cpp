#include "MenuScene.h"

#include "RopeGame.h"

#include "../commons.h"
#include "../Configuration.h"
#include "../Logging.h"

#include <graphics/CameraUtilities.h>


namespace ad {
namespace grapito {


Menu makePauseMenu()
{
    return Menu {
        std::vector<UiButton>{
            { "Resume",
              [](StateMachine & aMachine, std::shared_ptr<graphics::AppInterface> &)
                {
                    aMachine.popState(); // this
                }
            },
            { "Restart level",
              [](StateMachine & aMachine, std::shared_ptr<graphics::AppInterface> & aAppInterface)
                {
                    aMachine.popState(); // this
                    aMachine.popState(); // running game
                    aMachine.emplaceState<RopeGame>(aAppInterface); // new game
                }
            },
            { "Exit to Main Menu",
              [](StateMachine & aMachine, std::shared_ptr<graphics::AppInterface> & aAppInterface)
                {
                    aMachine.popState(); // this
                    aMachine.popState(); // running game
                }
            },
        },
    };
}


MenuScene::MenuScene(Menu aMenu, std::shared_ptr<graphics::AppInterface> aAppInterface) :
    mMenu{std::move(aMenu)},
    mAppInterface{std::move(aAppInterface)},
    mShaping{mAppInterface->getFramebufferSize()}
{
    setViewedRectangle(
        mShaping,
        graphics::getViewRectangle(mAppInterface->getFramebufferSize(), menu::gViewedHeight));
}


UpdateStatus MenuScene::update(
        GrapitoTimer & aTimer,
        const GameInputState & aInputs,
        StateMachine & aStateMachine)
{
    graphics::AppInterface::clear();

    if (aInputs.get(Controller::Keyboard)[Command::Up].positiveEdge())
    {
        mMenu.mSelected = std::min(mMenu.mSelected - 1, mMenu.size() - 1);
    }
    else if (aInputs.get(Controller::Keyboard)[Command::Down].positiveEdge())
    {
        mMenu.mSelected = (mMenu.mSelected + 1) % mMenu.size();
    }
    else if (aInputs.get(Controller::Keyboard)[Command::Start].positiveEdge())
    {
        mMenu.selected().mCallback(aStateMachine, mAppInterface);
        // When the menu is poping itself, the OpenGL is issuing an error when return SwapBuffers:
        // GL_INVALID_VALUE error generated. Program handle does not refer to an object generated by OpenGL.
        // We avoid it by not swapping to cover this case.
        // TODO get a better understanding of the error scenario.
        return UpdateStatus::KeepFrame;
    }

    GLfloat height = mMenu.size() * menu::gButtonSize.height()
        + (mMenu.size() - 1) * menu::gButtonSpacing;
    GLfloat buttonY = height / 2.f - menu::gButtonSize.height() / 2.f;
    GLfloat incrementY = menu::gButtonSize.height() + menu::gButtonSpacing;

    for (std::size_t buttonId = 0; buttonId != mMenu.size(); ++buttonId)
    {
        mShaping.addRectangle({
            Rectangle{ {0.f, buttonY}, menu::gButtonSize }.centered(),
            buttonId == mMenu.mSelected ? menu::gSelectedColor : menu::gButtonColor });
        buttonY -= incrementY;
    }
    mShaping.render();

    return UpdateStatus::SwapBuffers;
}


} // namespace grapito
} // namespace ad
