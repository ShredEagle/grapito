#include "MenuScene.h"

#include "RopeGame.h"

#include "../commons.h"
#include "../Configuration.h"
#include "../Logging.h"

#include "../Utils/DrawDebugStuff.h"

#include <math/VectorUtilities.h>

#include <graphics/CameraUtilities.h>

#include <resource/PathProvider.h>


namespace ad {
namespace grapito {


auto makeInterpolation(std::shared_ptr<graphics::AppInterface> aAppInterface, GLfloat aStartFactor, GLfloat aEndFactor)
{
    GLfloat viewedWidth_w = math::getRatio<float>(aAppInterface->getFramebufferSize()) * menu::gViewedHeight;
    return math::makeInterpolation<math::ease::SmoothStep>(
        aStartFactor * viewedWidth_w,
        aEndFactor   * viewedWidth_w,
        menu::gTransitionDuration);
}

MenuScene::MenuScene(Menu aMenu,
                     std::shared_ptr<graphics::AppInterface> aAppInterface,
                     std::shared_ptr<GameScene> aGameScene) :
    mMenu{std::move(aMenu)},
    mAppInterface{std::move(aAppInterface)},
    mOptionalGameScene{aGameScene},
    mRenderEffect{mAppInterface},
    mShaping{mAppInterface->getFramebufferSize()},
    mTexting{resource::pathFor(menu::gFont), menu::gTextHeight, menu::gViewedHeight, mAppInterface},
    // Useless, it is setup before transitions. But there is no default ctor.
    mMenuXPosition{makeInterpolation(mAppInterface, 0.f, 0.f)} 
{}


UpdateStatus MenuScene::update(
        GrapitoTimer & aTimer,
        const GameInputState & aInputs,
        StateMachine & aStateMachine)
{
    if (aInputs.get(Controller::Keyboard)[Command::Up].positiveEdge())
    {
        mMenu.mSelected = std::min(mMenu.mSelected - 1, mMenu.size() - 1);
    }
    else if (aInputs.get(Controller::Keyboard)[Command::Down].positiveEdge())
    {
        mMenu.mSelected = (mMenu.mSelected + 1) % mMenu.size();
    }
    else if (aInputs.get(Controller::Keyboard)[Command::Start].positiveEdge())
    {
        mMenu.selected().mCallback(aStateMachine, mAppInterface);
        // When the menu is poping itself, the OpenGL is issuing an error when return SwapBuffers:
        // GL_INVALID_VALUE error generated. Program handle does not refer to an object generated by OpenGL.
        // We avoid it by not swapping to cover this case.
        // TODO get a better understanding of the error scenario.
        return UpdateStatus::KeepFrame;
    }

    renderMenu();
    return UpdateStatus::SwapBuffers;
}

void MenuScene::beforeEnter()
{
    mMenuXPosition = makeInterpolation(mAppInterface, 0.5f, -0.5f);
}


void MenuScene::beforeExit()
{
    mMenuXPosition = makeInterpolation(mAppInterface, -0.5f, -1.5f);
}


std::pair<TransitionProgress, UpdateStatus> MenuScene::scrollMenu(GrapitoTimer & aTimer)
{
    Rectangle viewed = graphics::getViewRectangle(mAppInterface->getFramebufferSize(), menu::gViewedHeight);
    viewed.origin().x() = mMenuXPosition.advance(aTimer.delta());
    setViewedRectangle(mShaping, viewed);
    debugDrawer->setViewedRectangle(viewed);
    renderMenu();

    return {
        mMenuXPosition.isCompleted() ? TransitionProgress::Complete : TransitionProgress::Ongoing,
        UpdateStatus::SwapBuffers
    };
}


void MenuScene::renderMenu()
{
    graphics::AppInterface::clear();

    if (mOptionalGameScene)
    {
        mRenderEffect.blurTo(*mOptionalGameScene, graphics::FrameBuffer::Default(), menu::gBlurringPasses);
    }

    GLfloat menuHeight = mMenu.size() * menu::gButtonSize.height()
        + (mMenu.size() - 1) * menu::gButtonSpacing;
    GLfloat buttonY = menuHeight / 2.f - menu::gButtonSize.height() / 2.f;
    GLfloat incrementY = menu::gButtonSize.height() + menu::gButtonSpacing;

    mStrings.clear();
    for (std::size_t buttonId = 0; buttonId != mMenu.size(); ++buttonId)
    {
        math::Position<2, GLfloat> buttonCenter{0.f, buttonY};

        math::Rectangle<GLfloat> textBoundingBox =
            mTexting.getStringBounds(mMenu[buttonId].mText, { 0.f, 0.f });
        // The offset from the center of the bounding box to the initial pen position (origin)
        math::Vec<2, GLfloat> centeringPenOffset = -textBoundingBox.center().as<math::Vec>();
        mTexting.prepareString(mMenu[buttonId].mText, buttonCenter + centeringPenOffset, mStrings);
        debugDrawer->drawOutline(
            mTexting.getStringBounds(mMenu[buttonId].mText, buttonCenter + centeringPenOffset));

        mShaping.addRectangle({
            Rectangle{ buttonCenter , menu::gButtonSize }.centered(),
            buttonId == mMenu.mSelected ? menu::gSelectedColor : menu::gButtonColor });
        buttonY -= incrementY;
    }
    mTexting.updateInstances(mStrings);
    mShaping.render();
    mTexting.render();
}


} // namespace grapito
} // namespace ad
